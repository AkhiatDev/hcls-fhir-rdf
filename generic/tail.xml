
<!-- We'll traverse the FHIR instance XML data ($this param) while
     simultanously hopping around a build-in XML structure describing
     each FHIR path and its associated types + sub-propeties ($context param)
     We kick things off from the XML root element... -->
<xsl:template match="/*">
    <xsl:call-template name="addPrefixes">
        <xsl:with-param name="name" select="name()"/>
    </xsl:call-template>
    <xsl:call-template name="FhirElement">
        <xsl:with-param name="depth" select="0"/>
        <xsl:with-param name="this" select="."/>
        <xsl:with-param name="context" select="name()"/>
    </xsl:call-template>
</xsl:template>

<!-- This should be relaced with something less verbose to call -->
<xsl:template name="FhirIndent">
    <xsl:param name="depth" />
    <xsl:text>   </xsl:text>
    <xsl:if test="$depth > 0">
        <xsl:call-template name="FhirIndent">
            <xsl:with-param name="depth" select="number($depth)-1"/>
        </xsl:call-template>
    </xsl:if>
</xsl:template>

<!-- called with any f:extension elements anywhere, anytime, you name it, buddy.
change
      from:                                    to:
  <modifierExtension>                     <http://...plus> [
    <url value="http://...plus"/>            a fhir:modified_integer;
    <valueInteger value="2"/>                <http://...times> [
    <modifierExtension>                         a fhir:modified_integer;
      <url value="http://...times"/>            fhir:value "5";
      <valueInteger value="5"/>              ];
    </modifierExtension>                     fhir:modifiedBy <http://...times>;
  </modifierExtension>                       fhir:value "2";
                                          ];
                                          fhir:modifiedBy <http://...plus>;
 -->
<xsl:template name="extension">
  <xsl:param name="depth"/>
  <xsl:param name="this"/>

  <!-- find the (one) value element, e.g. f:valueInteger -->
  <xsl:for-each select="*[substring(name(), 1, 5)='value']">

    <!-- change 'f:valueInteger' into 'integer' -->
    <xsl:variable name="type1" select="substring(name(), 6)"/>
    <xsl:variable name="type">
      <xsl:choose> <!-- Fix cases in narrow minority of supported type names.-->
	<xsl:when test="$type1='Integer'"     ><xsl:value-of select="'integer'"     /></xsl:when>
	<xsl:when test="$type1='Decimal'"     ><xsl:value-of select="'decimal'"     /></xsl:when>
	<xsl:when test="$type1='DateTime'"    ><xsl:value-of select="'dateTime'"    /></xsl:when>
	<xsl:when test="$type1='Date'"        ><xsl:value-of select="'date'"        /></xsl:when>
	<xsl:when test="$type1='Instant'"     ><xsl:value-of select="'instant'"     /></xsl:when>
	<xsl:when test="$type1='String'"      ><xsl:value-of select="'string'"      /></xsl:when>
	<xsl:when test="$type1='Uri'"         ><xsl:value-of select="'uri'"         /></xsl:when>
	<xsl:when test="$type1='Boolean'"     ><xsl:value-of select="'boolean'"     /></xsl:when>
	<xsl:when test="$type1='Code'"        ><xsl:value-of select="'code'"        /></xsl:when>
	<xsl:when test="$type1='Base64Binary'"><xsl:value-of select="'base64Binary'"/></xsl:when>
	<xsl:otherwise><xsl:value-of select="$type1"/></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <!-- <xsl:variable name="type" select="concat(translate(substring(name(), 6, 1), -->
    <!-- 				                       'ABCDEFGHIJKLMNOPQRSTUVWXYZ', -->
    <!-- 				                       'abcdefghijklmnopqrstuvwxyz'), -->
    <!-- 				             substring(name(), 7))"/> -->
    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="$depth+1"/> </xsl:call-template>

    <!-- <http://...plus> [ -->
    <xsl:text>&lt;</xsl:text><xsl:value-of select="../f:url/@value"/><xsl:text>&gt; [</xsl:text>
    <xsl:call-template name="FhirElement">
      <xsl:with-param name="depth" select="$depth+1"/>
      <xsl:with-param name="this" select="."/>
      <xsl:with-param name="context" select="$type"/>
    </xsl:call-template>
    <!-- ]; -->
    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="$depth+1"/> </xsl:call-template>
    <xsl:text>];&#10;</xsl:text>
  </xsl:for-each>

  <xsl:if test="name(.)='modifierExtension'">
    <!-- fhir:modifiedBy <http://...plus>; -->
    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="$depth+1"/> </xsl:call-template>
    <xsl:value-of select="'fhir:modifiedBy '"/>
    <xsl:text>&lt;</xsl:text><xsl:value-of select="f:url/@value"/><xsl:text>&gt;;&#10;</xsl:text>
  </xsl:if>
</xsl:template>

<xsl:template name="FhirElement">

    <!-- mainly just indentation bookkeeping -->
    <xsl:param name="depth" />

    <!-- where we are in the FHIR instance XML payload -->
    <xsl:param name="this" />

    <!-- path into the accompanying FHIR definitions (built in to this XSLT) -->
    <xsl:param name="context" />

    <!-- XSLT makes meta-programming a drag.  But here, we look up the relevant node in our FHIR 
         definitions, keying off of the $context param (which is a fhir_path value) --> 
    <xsl:variable name="def" select="document('')/*/l:fhirdefs/path/fhir_path[text()=$context]/.."/>

    <!-- Type of the current element. Type can be null (for internal nodes) -->
    <xsl:variable name="def.type" select="$def/type"/>

    <!-- Sub-elemenets that are defined for this type.  Each sub includes 
           * an xpath fragment (e.g. 'f:detail')
           * FHIR path (e.g. Order.detail)
           * target type (e.g. CodeableConcept; or blank if the target is an internal node) -->
    <xsl:variable name="def.subs" select="$def/subs/sub"/> 

    <xsl:choose>
        <!-- TODO custom handlers for the basic tpyes: uri, string, code-->
        <!-- TODO possibly handlers for (some) datatyes: e.g. text-->

        <!-- This first branch represents a leaf node for which no further properties are defined in FHIR Spreadsheets -->
        <xsl:when test="not($def)">

            <xsl:text>&#10;</xsl:text>
            <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
            <xsl:text>a fhir:</xsl:text>
	    <xsl:if test="name(..)='modifierExtension'">
	      <xsl:text>modifying_</xsl:text> <!-- a modifying_integer -->
	    </xsl:if>
            <xsl:value-of select="$context"/>
            <xsl:text>;&#10;</xsl:text>
	    <xsl:for-each select="../*[name(.)='extension' or name(.)='modifierExtension']">
	      <xsl:call-template name="extension">
		<xsl:with-param name="depth" select="$depth"/>
		<xsl:with-param name="this" select="."/>
	      </xsl:call-template>
	    </xsl:for-each>		
            <xsl:if test="$context = 'Resource'"> <!--  or $context = 'resource'" -->
                <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                <xsl:text>a fhir:</xsl:text>
                <xsl:value-of select="$this/f:type/@value"/>
                <xsl:text>Reference;&#10;</xsl:text>
                <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                <xsl:text>Reference:reference &lt;</xsl:text>
                <xsl:value-of select="$this/f:reference/@value"/>
                <xsl:text>&gt;;&#10;</xsl:text>
                <xsl:if test="$this/f:display/@value">
                    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                    <xsl:text>Reference:display [&#10;</xsl:text>
                    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="2+$depth"/> </xsl:call-template>
                    <xsl:text>a fhir:String; fhir:value "</xsl:text>
                    <xsl:value-of select="$this/f:display/@value"/>
                    <xsl:text>"&#10;</xsl:text>
                    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                    <xsl:text>]&#10;</xsl:text>
                </xsl:if>
            </xsl:if>

            <xsl:if test="$this/@value">
                <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                <xsl:text>fhir:value "</xsl:text><xsl:value-of select="$this/@value"  />
                <xsl:text>";&#10;</xsl:text>
            </xsl:if>
            <xsl:if test="$context='xhtml'">
                <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="1+$depth"/> </xsl:call-template>
                <xsl:text>fhir:text """</xsl:text>
		<xsl:for-each select="$this">
		    <xsl:call-template name="copy-element" />
	        </xsl:for-each>
                <xsl:value-of select="$this/text()"/>
                <xsl:text>""";&#10;</xsl:text>
            </xsl:if>
        </xsl:when>

        <!-- This second branch represents a node with subproperties defined in FHIR Spreadsheets -->
        <xsl:otherwise>
            <xsl:if test="$depth=0">[] </xsl:if>
            <xsl:if test="$depth>0"><xsl:text>&#10;</xsl:text></xsl:if>

            <!-- If this is a type (non-internal) node, output the type -->
            <xsl:if test="$def.type != ''">
                <xsl:if test="$depth>0">
                    <xsl:call-template name="FhirIndent"> <xsl:with-param name="depth" select="$depth+1"/> </xsl:call-template>
                </xsl:if>
                <xsl:text>a :</xsl:text>
		<xsl:choose>
		  <xsl:when test="f:modifierExtension">
		    <!-- <Resource>:modified_<Property>  -->
		    <xsl:value-of select="concat('modified_', $def.type)"/>
		  </xsl:when>
		  <xsl:otherwise><xsl:value-of select="$def.type"/></xsl:otherwise>
		</xsl:choose>
                <xsl:text>;&#10;</xsl:text>
            </xsl:if>

	    <xsl:for-each select="*[name(.)='extension' or name(.)='modifierExtension']">
	      <xsl:call-template name="extension">
		<xsl:with-param name="depth" select="$depth"/>
		<xsl:with-param name="this" select="."/>
	      </xsl:call-template>
	    </xsl:for-each>		
            <!-- Iterate over defined subproperties, making a recursive application of FhirElement -->
            <xsl:for-each select="$def.subs">

                <xsl:variable name="last_property_p">
                    <xsl:choose>
                        <xsl:when test="position() = last()"><xsl:value-of select="true()"/></xsl:when>
                        <xsl:otherwise><xsl:value-of select="false()"/></xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="sub" select="."/>
                <xsl:variable name="predicate" select="./predicate"/>
                <xsl:variable name="fhir_path" select="./fhir_path"/>
                <xsl:variable name="type" select="./type"/>
                <xsl:variable name="xpath" select="substring-after(./relative_xpath, ':')"/>
                <!--searching on  <xsl:value-of select="$predicate"/> via <xsl:value-of select="$xpath"/>-->

                <!-- for a given property, look for its occurence(s) in instance data -->
                <xsl:for-each select="$this/*[name()=$xpath]">

                    <xsl:variable name="last_instance_p">
                        <xsl:choose>
                            <xsl:when test="position() = last()"><xsl:value-of select="true()"/></xsl:when>
                            <xsl:otherwise><xsl:value-of select="false()"/></xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>


                    <xsl:call-template name="FhirIndent"><xsl:with-param name="depth" select="$depth+1"/></xsl:call-template>
		    <xsl:choose>
		      <xsl:when test="f:modifierExtension">
			<!-- <Resource>:modified_<Property>  -->
			<xsl:value-of select="concat(substring-before($predicate, ':'),
					      ':modified_',
					      substring-after($predicate, ':'))"/>
		      </xsl:when>
		      <xsl:otherwise><xsl:value-of select="$predicate"/></xsl:otherwise>
		    </xsl:choose>
                    <xsl:text> </xsl:text> 
                    <xsl:variable name="subcontext">
                        <xsl:choose>
                            <xsl:when test="$type != ''">
                                <xsl:value-of select="$type"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="$fhir_path"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:text>[</xsl:text>
                    <xsl:call-template name="FhirElement">
                        <xsl:with-param name="depth" select="$depth+1"/>
                        <xsl:with-param name="this" select="."/>
                        <xsl:with-param name="context" select="$subcontext"/>
                    </xsl:call-template>
                    <xsl:call-template name="FhirIndent"><xsl:with-param name="depth" select="$depth+1"/></xsl:call-template>

                    <!-- This test only works because FHIR's examples are all serialized with propertiese
                         in the same order as in the defining spreadsheets.  It will sometimes think a
                         terminal entry is non-terminal, e.g. if the last property has no instance. -->
                    <xsl:choose>
                        <xsl:when test="$last_property_p='true' and $last_instance_p='true'">
                            <xsl:text>]&#10;</xsl:text> 
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>];&#10;</xsl:text> 
                        </xsl:otherwise>
                    </xsl:choose>

                </xsl:for-each>
            </xsl:for-each>
            <xsl:if test="$depth=0">.</xsl:if>
        </xsl:otherwise>
    </xsl:choose>
</xsl:template>
  <xsl:template name="copy-element" match="*" mode="copy">
    <xsl:text>&lt;</xsl:text><xsl:value-of select="name()"/>
    <xsl:apply-templates select="@*" mode="copy-attr"/>
    <xsl:choose>
      <xsl:when test="count(node()) > 0">
	<xsl:text>&gt;</xsl:text>
	<xsl:apply-templates select="node()" mode="copy" />
	<xsl:text>&lt;/</xsl:text><xsl:value-of select="name()"/><xsl:text>&gt;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
	<xsl:text>/&gt;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="copy-attr" match="@*" mode="copy-attr">
    <xsl:text> </xsl:text><xsl:value-of select="name()"/><xsl:text>=</xsl:text><xsl:text>"</xsl:text><xsl:value-of select="."/><xsl:text>"</xsl:text>
  </xsl:template>

  <xsl:template name="indent">
    <xsl:if test="preceding-sibling::text()[1]">
      <xsl:choose>
	<xsl:when test="contains(preceding-sibling::text()[1], '&#10;')">
	  <xsl:value-of select="substring-after(preceding-sibling::text()[1], '&#10;')"/>
	</xsl:when>
	<xsl:otherwise>
	  <xsl:value-of select="preceding-sibling::text()[1]"/>
	</xsl:otherwise>
      </xsl:choose>
    </xsl:if>
  </xsl:template>

  <!-- prefix for this resource plus library types. -->
  <xsl:template name="addPrefixes">
    <xsl:param name="name"/>
    <div>
      <pre class="machine" style="font-size:small">@prefix <xsl:value-of select="$name"/>: &lt;http://hl7/org/fhir/<xsl:value-of select="$name"/>#&gt; .
@prefix fhir: &lt;http://hl7/org/fhir/&gt; .
@prefix Narrative: &lt;http://hl7/org/fhir/Narrative#&gt; .
@prefix Observation: &lt;http://hl7/org/fhir/Observation#&gt; .
@prefix Quantity: &lt;http://hl7/org/fhir/Quantity#&gt; .
@prefix Resource: &lt;http://hl7/org/fhir/Resource#&gt; .
@prefix Reference: &lt;http://hl7/org/fhir/Reference#&gt; .
@prefix Range: &lt;http://hl7/org/fhir/Range#&gt; .
@prefix Codeable: &lt;http://hl7/org/fhir/Codeable#&gt; .
@prefix Coding: &lt;http://hl7/org/fhir/Coding#&gt; .
@prefix xhtml: &lt;http://www.w3.org/1999/xhtml&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema&gt; .
@base &lt;http://this-fhir-server/fhir/&gt; .
</pre>
    </div>
  </xsl:template>

</xsl:stylesheet>
